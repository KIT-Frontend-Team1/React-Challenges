5. React.memo
- React의 성능 최적화 기능 중 하나이다. 함수형 컴포넌트나 클래스형 컴포넌트의 render 메서드에서 반환하는 결과를 memoization하여, 같은 props로 다시 렌더링될 때 렌더링 결과를 캐시하고, 불필요한 렌더링을 방지한다. 컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 설정해줄 수 있다.

- 리액트에서 제공하는 고차 컴포넌트(HOC:Higher Order Component), 고차 컴포넌트란 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수로 React.memo의 경우

일반 컴포넌트 ->  React.memo -> 최적화된 컴포넌트(props에 변화의 유무를 따짐, 있다면 렌더링, 없다면 기존 memoization된 렌더링의 내용을 재사용)

예시)
부모 컴포넌트에서 자식 컴포넌트를 렌더링하는 경우, 부모 컴포넌트의 state나 props가 변경되어도 자식 컴포넌트의 props가 변경되지 않으면 자식 컴포넌트는 다시 렌더링될 필요가 없다. 이 경우, React.memo를 사용하여 자식 컴포넌트의 불필요한 렌더링을 방지할 수 있다.

const Child = ({name, age, company}) => {
  return (
    <div>
      <p>{name}</p>
      <p>{age}</p>
      <p>{company}</p>
    </div>
  );
};

const Parent = (props) => {
  return (
    <Child
      name={'허윤진'}
      age={'23'}
      company={'hybe'}
    />
  );
};

여기서 Parent가 렌더링되면 Child가 같이 렌더링되는데 만약 Parent가 자주 변경되는 컴포넌트라면 Child는 늘 같은 결과를 보여줌에도 불구하고 계속해서 Parent와 같이 렌더링 된다. 만약 Child 컴포넌트에서 복잡한 로직을 처리하는 경우 성능이 현저히 떨어질 수 있는 문제가 된다.
이때 React.memo로 Child가 최적화가 된다면 Child가 받는 props(name, age, company)가 변경될 때만 렌더링되게 할 수 있다.


React.memo의 장점?
1) 렌더링 횟수 감소로 인한 성능 향상
- props가 변경되지 않는 경우, 불필요한 렌더링을 방지하여 렌더링 횟수를 감소시켜 최적화와 성능 향상을 할 수 있다.
2) 적용이 쉽다
- 함수형 컴포넌트나 클래스형 컴포넌트 모두 쉽게 적용 가능하다.
3) 코드를 더욱 간결하고 가독성있게 작성 가능하다.

React.memo의 단점?
1) 메모리의 사용
- React.memo 또한 결과를 memoization 담아주는 것이므로 메모리를 추가 소비하는 것이므로, 이전 결과를 재사용하는 것이 성능적으로 유리한 경우일 때만 사용해한다. 그 외의 상황에서는 오히려 성능에 좋지 않을 수 있다.
2) 제한된 적용
- 모든 컴포넌트에 React.memo를 적용하는 것은 항상 좋은 것이 아니다. props가 자주 변경되거나 컴포넌트가 자주 변경되는 경우 오히려 성능에 좋지 않을 수 있다.

그럼 이 React.memo는 어떤 상황에서 제일 적합할까?
1) 컴포넌트가 같은 props로 자주 렌더링될 때
2) 컴포넌트가 렌더링 될 때마다 복잡한 로직을 처리해야할 때
* React.memo는 오직 props 변화에만 의존하는 최적화 방법이다.