4. useCallback
- 리렌더링 사이에 함수 정의를 저장(캐싱)하는 React Hook이다.
- 컴포넌트 최초 렌더링 시 함수 객체를 만들어 useCallback에 캐싱해주어 초기화 해주고, 그 이후 렌더링 시 만들어 놓은 함수 객체를 계속 불러오는 것이 아닌 가지고 있는 함수 객체를 재사용을 하는 것


기본 형태는 이러하다
const calcuate = useCallback((num) => {
  return num + 1;
}, [item])


첫 번째 인자 > 콜백 함수
두 번째 인자 > 의존성 배열, 의존성 배열 내부 값이 바뀌지 않는 이상 다시 초기화 되지 않는다.

useCallback의 장점?
- state에서의 최적화
: React 컴포넌트에서는 상태(state)나 속성(props)이 변경될 때마다 컴포넌트가 다시 렌더링 되는데, 함수형 컴포넌트 내부에 선언된 함수들은 매번 컴포넌트가 렌더링 될 때마다 새로운 함수 인스턴스가 생성된다. 이 경우, 컴포넌트의 속성값이나 상태값에 변경이 없더라도, 매번 함수 인스턴스가 새로 생성되기 때문에 성능에 문제가 될 수 있다.
-> 이 때 useCallback을 사용하여 성능을 최적화하는데 useCallback은 함수를 캐싱하고, 해당 함수가 변경되지 않는 한 이전에 캐싱된 함수를 가져온다. 동일 함수의 재사용으로 불필요한 함수 생성, 초기화를 막아줄 수 있다. 방지할 수 있다.
- 의존성 배열의 사용으로 새로운 함수의 생성을 방지하고, 의존성 배열의 값이 변경될 때만 함수를 업데이트
- 자식 컴포넌트에 props로 전달하는 함수들에 대해서도 최적화 가능

useCallback의 단점?
- 코드의 복잡성 증가
: 모든 함수에 적용하는 것이 아닌 성능 최적화가 필요한 함수에만 적용해야한다. 그러지 않는다면 오히려 코드의 복잡성이 높아지고 성능 저하의 문제가 발생한다.
- 메모리 사용량 증가
: 함수를 캐싱하는 방식이므로 메모리를 사용하기 때문에 메모리 사용량이 증가할 수 있다.

-> 특정 상황에서 최적화가 필요할 때만 사용하는 것이 필요할 것 같다.