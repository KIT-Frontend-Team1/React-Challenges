1. useState
- 리액트에서 State란? 컴포넌트의 상태(State)를 말한다.
- 컴포넌트에서 데이터를 선언하고 변경하기 위해 useState라는 함수를 사용하는데 이 함수는 컴포넌트의 상태를 간편하게 생성하고 업데이트를 시켜준다.

기본 형태는 이러하다
const [ state, setState ] = useState(초기값);

state 생성과 동시에 초기값을 갖도록 useState 함수의 인자값으로 넣어주면 state, setState를 배열 형태로 리턴해준다.

여기서 state는 현재 상태값이고, setState를 사용하여 상태값을 변경해줄 수 있다. 변경 시 화면에 업데이트되어 리렌더링된다.

사용 예시를 간단하게 알아보자면
function App() {
 const count = 0;

 return (
  <div>
   {count}
   <button onClick={() => count += 1}>Add +1</button>
  </div>
 )
}

state를 사용하지 않고 일반 변수를 사용한다면 버튼 클릭 시 UI에 아무런 변화가 일어나지 않는다.
여기서 아래와 같이 state로 상태 변화를 해주어야 한다.

import { useState } from 'react';

function App() {
 const [ count, setCount ] = useState(0);

 return (
  <div>
   {count}
   <button onClick={() => setCount(count + 1)}>Add +1</button>
  </div>
 )
}

useState를 사용하여 상태 변화를 해주면 state가 포함된 html를 자동으로 리렌더링해준다.
실제 DOM의 경우 변경사항이 생기면 html에서 하나하나 바꿔줘야하는데 리액트의 state는 그럴 필요가 없다는 것이다.

그렇다면 모든 데이터를 state로 만들어 데이터 바인딩을 해야하는가?
아니다.
바뀔일이 없는 데이터들은 일반 변수로 저장해 사용하면 된다.
예를 들어 페이지 타이틀명(로고명, 블로그명 등)은 일반 변수에 담아 사용하면 된다.

그럼 이 useState는 언제 사용하는가?
-> 리액트에서 UI와 밀접한 관련이 있는 데이터, 변경해주어야하는 데이터들은 state에 보관을 해주어야 한다.

=============================
useState의 장점을 더 알아보자면?

1) UI가 변경되어야하는 데이터에 유용하다.
- 실제 DOM에서는 일반 변수값이 변경되면 html을 직접 조작해야하는 번거로움이 있는데 state는 변경 시에 state가 포함된 html을 자동으로 렌더링해주므로 직접 html을 건드리지 않아 UI 기능 개발에 편리해진다.

2) 상태 관리와 업데이트를 쉽고 간편하게 해준다.
- React hooks가 나오기 전 상태값을 관리하기 위해 클래스 컴포넌트를 사용했으나 간단한 상태 관리조차 복잡하였다. 함수형 컴포넌트 hook의 등장으로 상태 관리가 훨씬 간편해져 가독성과 유지 보수성이 뛰어남이 특징이다.

3) 성능 최적화
- useState는 이전 상태를 자동 추적하여 상태를 변경할 때 불필요한 렌더링을 방지하는 성능상의 이점이 있다.

4) 코드의 중복을 줄일 수 있다.
- useState를 사용하면 컴포넌트 내에서 상태를 쉽게 관리할 수 있으므로 코드 중복성을 줄여 가독성과 유지 보수성을 높일 수 있다.

5) 다른 hook 함수와 함께 사용하여 기능 확장이 가능하다.
- useState는 리액트 훅 함수 중 하나이므로 다른 훅 함수와 함께 사용하여 컴포넌트의 기능을 확장할 수 있다. 예를 들어 useEffect를 사용하여 컴포넌트가 마운트, 언마운트, 상태 업데이트 시 특정 작업을 할 수 있다.


useState의 단점은?

1) 객체나 배열과 같은 복잡한 데이터를 관리하기 어렵다.
- useState는 간단한 데이터를 관리하는데 적합하나 객체나 배열을 관리할 경우 이전 상태와 새로운 상태를 병합해주는 과정이 복잡하여 가독성에 좋지 않을 수 있다.
=> 복잡한 데이터를 관리할 떄 useReducer 함수를 사용하여 상태 업데이트 로직을 분리하여 좀 더 쉽게 다룰 수 있다.

2) 상태의 불변성 유지가 어렵다.
- useState로 관리하는 상태값은 불변성을 유지해야하는데 이를 유지하지 않으면 올바른 동작이 일어나지 않을 수 있다.

// 예시
const [state, setState] = useState([1, 2, 3]);
state.push(4);

=> 이때 state 배열은 직접 수정되므로 useState의 동작 방식에 맞지 않는다.

// spread 연산자를 사용해야한다.
const [state, setState] = useState([1, 2, 3]);
setState(prev => [...prev, 4]);