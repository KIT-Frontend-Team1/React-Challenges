1. useState
   함수형 컴포넌트에서 상태를 관리하기 위해 사용되는 함수입니다

useState 함수를 호출하여 정의하고 변수에 할당함 이때 변수의 첫번째 값은 상태의
현재 값을 나타내고 두번째 값은 첫번째 값을 업데이트 할 수 잇는 함수

장점

- 여러개의 상태를 관리할 수 있다 -클래스형 컴포넌트에서 사용하는 setState보다 간결하고 직관적인 코드 작성 가능
- 상태를 업데이트 할 때마다 컴포넌트가 자동으로 렌더링됨
- 함수형 컴포넌트에서도 상태를 관리할 수 있다

단점

- 상태가 많이 복잡해지는 경우 관리가 어려울 수 있다
- 클래스형 컴포넌트에서 제공하는 라이프사이클 메서드를 사용할 수 없습니다

2. useRef

함수 호출 후 Ref 객체를 생성하고, 이를 변수에 할당합니다
이때 변수의 값은 null 또는 초기값으로 설정가능

장점

- 함수형 컴포넌트에서 Ref 객체를 생성하고 사용할 수 있습니다
- Ref객체를 사용하여 DOM 노드에 접근할 수 있습니다
- Ref객체를 사용하여 이전 상태와 현재 상태를 비교할 수 있습니다

단점

- 상태 업데이트와는 별개로 동작하기 때문에, 상태에 따라 다른 동작을 수행해야
  할때는 다른 방법을 사용해야함
- Ref 객체를 사용하면 컴포넌트가 렌더링 될 때마다 Ref객체를 새로 생성해서
  성능 저하가 발생할 수 있습니다(이를 방지하기 위해 useMemo를 같이 사용)

3. useMemo
   이전에 계산된 결과를 재사용한다

장점

- 계산 비용이 높은 함수의 실행을 최적화할 수 있습니다
- 불필요한 렌더링을 방지하고, 성능을 향상시킵니다

단점

- 의존성 리스트를 잘못 구성하면 예상치 못한 버그가 발생할 수 있습니다
- 모든 상황에서 성능 개선을 보장하지는 않습니다

4. useCallback
   함수를 재사용할 수 있게 도와주는 함수

장점 -함수 컴포넌트 내에서 렌더링시마다 함수를 재생성하는 문제를 해결해줍니다 -성능을 개선하여 컴포넌트의 불필요한 렌더링을 방지합니다

단점 -모든 함수에 useCallback을 적용하는 것이 좋지 않습니다
의존성 배열이 계속해서 변경되는 함수는 useCallback을 적용하지 않는 것이 성능상 유리합니다 -메모이제이션된 함수를 사용해야하는 상황이 아니라면, 불필요한 코드를 추가할 수 있습니다

5. React.memo
   이전에 계산된 값을 캐시하고, 이전에 동일한 입력이 제공되는 경우 이전 결과를 반환함으로써 계산 속도를 높이는 프로세스

React.memo는 내부적으로 shouldComponentUpdate 메서드를 구현합니다.
이 메서드는 이전 props와 현재 props를 비교하여 변경 여부를 결정합니다.
shouldComponentUpdate가 false를 반환하면 React는 렌더링을 건너뛰고 이전 결과를 재사용합니다

장점 -성능향상 -간편성

단점 -메모제이션은 추가적인 CPU 사이클 및 메모리를 필요로 하기 때문에
추가 오버헤드가 발생할 수 있다

- 리액트.메모는 PROPS에 대해서만 작동하기 때문에 다른 것에 대한 변경은
  자동으로 추적되지 않는다 (수동으로 재렌더링해야함)

6. useEffect
   useEffect를 사용하면 컴포넌트가 마운트되었을 때, 업데이트되었을 때,
   혹은 언마운트되었을 때 특정 작업을 수행할 수 있습니다

의존성 배열과 함께 쓴다 의존성 배열이 비어 있으면 함수는 한 번만 실행된다

장점 -컴포넌트 생명주기와 관련된 작업을 수행할 수 있습니다. -함수형 컴포넌트에서도 상태를 관리할 수 있도록 해줍니다. -비동기 작업을 수행할 수 있습니다. -여러 개의 useEffect를 사용하여 코드를 모듈화할 수 있습니다.

단점 -잘못 사용할 경우 메모리 누수와 같은 문제가 발생할 수 있습니다.
-useEffect 함수 안에서 상태를 변경하는 경우, 무한 루프에 빠질 수 있습니다. -함수가 매번 실행되므로 성능 문제가 발생할 수 있습니다.
이 경우, useMemo나 useCallback 등 다른 Hook을 사용하여 최적화할 수 있습니다.
